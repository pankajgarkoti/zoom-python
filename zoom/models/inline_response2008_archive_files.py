# coding: utf-8

"""
    Zoom Meeting API

    The Zoom Meeting APIs let developers to access information from Zoom.  # noqa: E501

    OpenAPI spec version: 2
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

import pprint
import re  # noqa: F401

import six

class InlineResponse2008ArchiveFiles(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    """
    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    swagger_types = {
        'download_url': 'str',
        'file_extension': 'str',
        'file_path': 'str',
        'file_size': 'int',
        'file_type': 'str',
        'id': 'str',
        'individual': 'bool',
        'participant_email': 'str',
        'participant_join_time': 'datetime',
        'participant_leave_time': 'datetime',
        'recording_type': 'str',
        'status': 'str',
        'encryption_fingerprint': 'str',
        'number_of_messages': 'int',
        'storage_location': 'str',
        'auto_delete': 'bool'
    }

    attribute_map = {
        'download_url': 'download_url',
        'file_extension': 'file_extension',
        'file_path': 'file_path',
        'file_size': 'file_size',
        'file_type': 'file_type',
        'id': 'id',
        'individual': 'individual',
        'participant_email': 'participant_email',
        'participant_join_time': 'participant_join_time',
        'participant_leave_time': 'participant_leave_time',
        'recording_type': 'recording_type',
        'status': 'status',
        'encryption_fingerprint': 'encryption_fingerprint',
        'number_of_messages': 'number_of_messages',
        'storage_location': 'storage_location',
        'auto_delete': 'auto_delete'
    }

    def __init__(self, download_url=None, file_extension=None, file_path=None, file_size=None, file_type=None, id=None, individual=None, participant_email=None, participant_join_time=None, participant_leave_time=None, recording_type=None, status=None, encryption_fingerprint=None, number_of_messages=None, storage_location=None, auto_delete=None):  # noqa: E501
        """InlineResponse2008ArchiveFiles - a model defined in Swagger"""  # noqa: E501
        self._download_url = None
        self._file_extension = None
        self._file_path = None
        self._file_size = None
        self._file_type = None
        self._id = None
        self._individual = None
        self._participant_email = None
        self._participant_join_time = None
        self._participant_leave_time = None
        self._recording_type = None
        self._status = None
        self._encryption_fingerprint = None
        self._number_of_messages = None
        self._storage_location = None
        self._auto_delete = None
        self.discriminator = None
        self.download_url = download_url
        self.file_extension = file_extension
        if file_path is not None:
            self.file_path = file_path
        self.file_size = file_size
        self.file_type = file_type
        self.id = id
        self.individual = individual
        if participant_email is not None:
            self.participant_email = participant_email
        self.participant_join_time = participant_join_time
        self.participant_leave_time = participant_leave_time
        self.recording_type = recording_type
        self.status = status
        self.encryption_fingerprint = encryption_fingerprint
        if number_of_messages is not None:
            self.number_of_messages = number_of_messages
        if storage_location is not None:
            self.storage_location = storage_location
        if auto_delete is not None:
            self.auto_delete = auto_delete

    @property
    def download_url(self):
        """Gets the download_url of this InlineResponse2008ArchiveFiles.  # noqa: E501

        The URL to download the the archive file.    **OAuth apps**    If a user has authorized and installed your OAuth app that contains recording scopes, use the user's [OAuth access token](https://developers.zoom.us/docs/integrations/oauth/) to download the file. For example:    `https://{{base-domain}}/rec/archive/download/xxx--header 'Authorization: Bearer {{OAuth-access-token}}'`    **Note:** This field does **not** return for [Zoom On-Premise accounts](https://support.zoom.us/hc/en-us/articles/360034064852-Zoom-On-Premise-Deployment). Instead, this API will return the `file_path` field.  # noqa: E501

        :return: The download_url of this InlineResponse2008ArchiveFiles.  # noqa: E501
        :rtype: str
        """
        return self._download_url

    @download_url.setter
    def download_url(self, download_url):
        """Sets the download_url of this InlineResponse2008ArchiveFiles.

        The URL to download the the archive file.    **OAuth apps**    If a user has authorized and installed your OAuth app that contains recording scopes, use the user's [OAuth access token](https://developers.zoom.us/docs/integrations/oauth/) to download the file. For example:    `https://{{base-domain}}/rec/archive/download/xxx--header 'Authorization: Bearer {{OAuth-access-token}}'`    **Note:** This field does **not** return for [Zoom On-Premise accounts](https://support.zoom.us/hc/en-us/articles/360034064852-Zoom-On-Premise-Deployment). Instead, this API will return the `file_path` field.  # noqa: E501

        :param download_url: The download_url of this InlineResponse2008ArchiveFiles.  # noqa: E501
        :type: str
        """
        if download_url is None:
            raise ValueError("Invalid value for `download_url`, must not be `None`")  # noqa: E501

        self._download_url = download_url

    @property
    def file_extension(self):
        """Gets the file_extension of this InlineResponse2008ArchiveFiles.  # noqa: E501

        The archived file's extension.  # noqa: E501

        :return: The file_extension of this InlineResponse2008ArchiveFiles.  # noqa: E501
        :rtype: str
        """
        return self._file_extension

    @file_extension.setter
    def file_extension(self, file_extension):
        """Sets the file_extension of this InlineResponse2008ArchiveFiles.

        The archived file's extension.  # noqa: E501

        :param file_extension: The file_extension of this InlineResponse2008ArchiveFiles.  # noqa: E501
        :type: str
        """
        if file_extension is None:
            raise ValueError("Invalid value for `file_extension`, must not be `None`")  # noqa: E501

        self._file_extension = file_extension

    @property
    def file_path(self):
        """Gets the file_path of this InlineResponse2008ArchiveFiles.  # noqa: E501

        The file path to the on-premise account archive file.    **Note:** The API only returns this field for [Zoom On-Premise accounts](https://support.zoom.us/hc/en-us/articles/360034064852-Zoom-On-Premise-Deployment). It does **not** return the `download_url` field.  # noqa: E501

        :return: The file_path of this InlineResponse2008ArchiveFiles.  # noqa: E501
        :rtype: str
        """
        return self._file_path

    @file_path.setter
    def file_path(self, file_path):
        """Sets the file_path of this InlineResponse2008ArchiveFiles.

        The file path to the on-premise account archive file.    **Note:** The API only returns this field for [Zoom On-Premise accounts](https://support.zoom.us/hc/en-us/articles/360034064852-Zoom-On-Premise-Deployment). It does **not** return the `download_url` field.  # noqa: E501

        :param file_path: The file_path of this InlineResponse2008ArchiveFiles.  # noqa: E501
        :type: str
        """

        self._file_path = file_path

    @property
    def file_size(self):
        """Gets the file_size of this InlineResponse2008ArchiveFiles.  # noqa: E501

        The archived file's size, in bytes.  # noqa: E501

        :return: The file_size of this InlineResponse2008ArchiveFiles.  # noqa: E501
        :rtype: int
        """
        return self._file_size

    @file_size.setter
    def file_size(self, file_size):
        """Sets the file_size of this InlineResponse2008ArchiveFiles.

        The archived file's size, in bytes.  # noqa: E501

        :param file_size: The file_size of this InlineResponse2008ArchiveFiles.  # noqa: E501
        :type: int
        """
        if file_size is None:
            raise ValueError("Invalid value for `file_size`, must not be `None`")  # noqa: E501

        self._file_size = file_size

    @property
    def file_type(self):
        """Gets the file_type of this InlineResponse2008ArchiveFiles.  # noqa: E501

        The archive file's type.  * `MP4` - Video file.  * `M4A` - Audio-only file.  * `CHAT` - A TXT file containing in-meeting chat messages.  * `CC` - A file containing the closed captions of the recording, in VTT file format.  * `CHAT_MESSAGE` - A JSON file encoded in base64 format containing chat messages. The file also includes waiting room chats, deleted messages, meeting emojis and non-verbal feedback.  # noqa: E501

        :return: The file_type of this InlineResponse2008ArchiveFiles.  # noqa: E501
        :rtype: str
        """
        return self._file_type

    @file_type.setter
    def file_type(self, file_type):
        """Sets the file_type of this InlineResponse2008ArchiveFiles.

        The archive file's type.  * `MP4` - Video file.  * `M4A` - Audio-only file.  * `CHAT` - A TXT file containing in-meeting chat messages.  * `CC` - A file containing the closed captions of the recording, in VTT file format.  * `CHAT_MESSAGE` - A JSON file encoded in base64 format containing chat messages. The file also includes waiting room chats, deleted messages, meeting emojis and non-verbal feedback.  # noqa: E501

        :param file_type: The file_type of this InlineResponse2008ArchiveFiles.  # noqa: E501
        :type: str
        """
        if file_type is None:
            raise ValueError("Invalid value for `file_type`, must not be `None`")  # noqa: E501
        allowed_values = ["MP4", "M4A", "CHAT", "CC", "CHAT_MESSAGE"]  # noqa: E501
        if file_type not in allowed_values:
            raise ValueError(
                "Invalid value for `file_type` ({0}), must be one of {1}"  # noqa: E501
                .format(file_type, allowed_values)
            )

        self._file_type = file_type

    @property
    def id(self):
        """Gets the id of this InlineResponse2008ArchiveFiles.  # noqa: E501

        The archive file's unique ID.  # noqa: E501

        :return: The id of this InlineResponse2008ArchiveFiles.  # noqa: E501
        :rtype: str
        """
        return self._id

    @id.setter
    def id(self, id):
        """Sets the id of this InlineResponse2008ArchiveFiles.

        The archive file's unique ID.  # noqa: E501

        :param id: The id of this InlineResponse2008ArchiveFiles.  # noqa: E501
        :type: str
        """
        if id is None:
            raise ValueError("Invalid value for `id`, must not be `None`")  # noqa: E501

        self._id = id

    @property
    def individual(self):
        """Gets the individual of this InlineResponse2008ArchiveFiles.  # noqa: E501

        Whether the archive file is an individual recording file.  * `true` - An individual recording file.   * `false` - An entire meeting file.  # noqa: E501

        :return: The individual of this InlineResponse2008ArchiveFiles.  # noqa: E501
        :rtype: bool
        """
        return self._individual

    @individual.setter
    def individual(self, individual):
        """Sets the individual of this InlineResponse2008ArchiveFiles.

        Whether the archive file is an individual recording file.  * `true` - An individual recording file.   * `false` - An entire meeting file.  # noqa: E501

        :param individual: The individual of this InlineResponse2008ArchiveFiles.  # noqa: E501
        :type: bool
        """
        if individual is None:
            raise ValueError("Invalid value for `individual`, must not be `None`")  # noqa: E501

        self._individual = individual

    @property
    def participant_email(self):
        """Gets the participant_email of this InlineResponse2008ArchiveFiles.  # noqa: E501

        The individual recording file's participant email address. This value is returned when the `individual` value is `true`. If the participant is **not** part of the host's account, this returns an empty string value, with some exceptions. See [Email address display rules](https://developers.zoom.us/docs/api/rest/using-zoom-apis/#email-address-display-rules) for details.  # noqa: E501

        :return: The participant_email of this InlineResponse2008ArchiveFiles.  # noqa: E501
        :rtype: str
        """
        return self._participant_email

    @participant_email.setter
    def participant_email(self, participant_email):
        """Sets the participant_email of this InlineResponse2008ArchiveFiles.

        The individual recording file's participant email address. This value is returned when the `individual` value is `true`. If the participant is **not** part of the host's account, this returns an empty string value, with some exceptions. See [Email address display rules](https://developers.zoom.us/docs/api/rest/using-zoom-apis/#email-address-display-rules) for details.  # noqa: E501

        :param participant_email: The participant_email of this InlineResponse2008ArchiveFiles.  # noqa: E501
        :type: str
        """

        self._participant_email = participant_email

    @property
    def participant_join_time(self):
        """Gets the participant_join_time of this InlineResponse2008ArchiveFiles.  # noqa: E501

        The join time for the generated recording file. If this value is returned when the individual value is true, then it is the recording file's participant join time. When the individual value is false, it returns the join time for the archiving gateway.  # noqa: E501

        :return: The participant_join_time of this InlineResponse2008ArchiveFiles.  # noqa: E501
        :rtype: datetime
        """
        return self._participant_join_time

    @participant_join_time.setter
    def participant_join_time(self, participant_join_time):
        """Sets the participant_join_time of this InlineResponse2008ArchiveFiles.

        The join time for the generated recording file. If this value is returned when the individual value is true, then it is the recording file's participant join time. When the individual value is false, it returns the join time for the archiving gateway.  # noqa: E501

        :param participant_join_time: The participant_join_time of this InlineResponse2008ArchiveFiles.  # noqa: E501
        :type: datetime
        """
        if participant_join_time is None:
            raise ValueError("Invalid value for `participant_join_time`, must not be `None`")  # noqa: E501

        self._participant_join_time = participant_join_time

    @property
    def participant_leave_time(self):
        """Gets the participant_leave_time of this InlineResponse2008ArchiveFiles.  # noqa: E501

        The leave time for the generated recording file. If this value is returned when the individual value is true, then it is the recording file's participant leave time. When the individual value is false, it returns the leave time for the archiving gateway.  # noqa: E501

        :return: The participant_leave_time of this InlineResponse2008ArchiveFiles.  # noqa: E501
        :rtype: datetime
        """
        return self._participant_leave_time

    @participant_leave_time.setter
    def participant_leave_time(self, participant_leave_time):
        """Sets the participant_leave_time of this InlineResponse2008ArchiveFiles.

        The leave time for the generated recording file. If this value is returned when the individual value is true, then it is the recording file's participant leave time. When the individual value is false, it returns the leave time for the archiving gateway.  # noqa: E501

        :param participant_leave_time: The participant_leave_time of this InlineResponse2008ArchiveFiles.  # noqa: E501
        :type: datetime
        """
        if participant_leave_time is None:
            raise ValueError("Invalid value for `participant_leave_time`, must not be `None`")  # noqa: E501

        self._participant_leave_time = participant_leave_time

    @property
    def recording_type(self):
        """Gets the recording_type of this InlineResponse2008ArchiveFiles.  # noqa: E501

        The archive file's recording type.  * `shared_screen_with_speaker_view`  * `audio_only`  * `chat_file`  * `closed_caption`  * `chat_message`    For more information, read our [Managing and sharing cloud recordings](https://support.zoom.us/hc/en-us/articles/205347605-Managing-and-sharing-cloud-recordings#h_9898497b-e736-4980-a749-d55608f10773) documentation.  # noqa: E501

        :return: The recording_type of this InlineResponse2008ArchiveFiles.  # noqa: E501
        :rtype: str
        """
        return self._recording_type

    @recording_type.setter
    def recording_type(self, recording_type):
        """Sets the recording_type of this InlineResponse2008ArchiveFiles.

        The archive file's recording type.  * `shared_screen_with_speaker_view`  * `audio_only`  * `chat_file`  * `closed_caption`  * `chat_message`    For more information, read our [Managing and sharing cloud recordings](https://support.zoom.us/hc/en-us/articles/205347605-Managing-and-sharing-cloud-recordings#h_9898497b-e736-4980-a749-d55608f10773) documentation.  # noqa: E501

        :param recording_type: The recording_type of this InlineResponse2008ArchiveFiles.  # noqa: E501
        :type: str
        """
        if recording_type is None:
            raise ValueError("Invalid value for `recording_type`, must not be `None`")  # noqa: E501
        allowed_values = ["shared_screen_with_speaker_view", "audio_only", "chat_file", "closed_caption", "chat_message"]  # noqa: E501
        if recording_type not in allowed_values:
            raise ValueError(
                "Invalid value for `recording_type` ({0}), must be one of {1}"  # noqa: E501
                .format(recording_type, allowed_values)
            )

        self._recording_type = recording_type

    @property
    def status(self):
        """Gets the status of this InlineResponse2008ArchiveFiles.  # noqa: E501

        The archived file's processing status.  * `completed` - The processing of the file is complete.  * `processing` - The file is processing.  * `failed` - The processing of the file failed.  # noqa: E501

        :return: The status of this InlineResponse2008ArchiveFiles.  # noqa: E501
        :rtype: str
        """
        return self._status

    @status.setter
    def status(self, status):
        """Sets the status of this InlineResponse2008ArchiveFiles.

        The archived file's processing status.  * `completed` - The processing of the file is complete.  * `processing` - The file is processing.  * `failed` - The processing of the file failed.  # noqa: E501

        :param status: The status of this InlineResponse2008ArchiveFiles.  # noqa: E501
        :type: str
        """
        if status is None:
            raise ValueError("Invalid value for `status`, must not be `None`")  # noqa: E501
        allowed_values = ["completed", "processing", "failed"]  # noqa: E501
        if status not in allowed_values:
            raise ValueError(
                "Invalid value for `status` ({0}), must be one of {1}"  # noqa: E501
                .format(status, allowed_values)
            )

        self._status = status

    @property
    def encryption_fingerprint(self):
        """Gets the encryption_fingerprint of this InlineResponse2008ArchiveFiles.  # noqa: E501

        The archived file's encryption fingerprint, using the SHA256 hash algorithm.  # noqa: E501

        :return: The encryption_fingerprint of this InlineResponse2008ArchiveFiles.  # noqa: E501
        :rtype: str
        """
        return self._encryption_fingerprint

    @encryption_fingerprint.setter
    def encryption_fingerprint(self, encryption_fingerprint):
        """Sets the encryption_fingerprint of this InlineResponse2008ArchiveFiles.

        The archived file's encryption fingerprint, using the SHA256 hash algorithm.  # noqa: E501

        :param encryption_fingerprint: The encryption_fingerprint of this InlineResponse2008ArchiveFiles.  # noqa: E501
        :type: str
        """
        if encryption_fingerprint is None:
            raise ValueError("Invalid value for `encryption_fingerprint`, must not be `None`")  # noqa: E501

        self._encryption_fingerprint = encryption_fingerprint

    @property
    def number_of_messages(self):
        """Gets the number_of_messages of this InlineResponse2008ArchiveFiles.  # noqa: E501

        The number of `TXT` or `JSON` file messages. This field returns only when the `file_extension` is `JSON` or `TXT`  # noqa: E501

        :return: The number_of_messages of this InlineResponse2008ArchiveFiles.  # noqa: E501
        :rtype: int
        """
        return self._number_of_messages

    @number_of_messages.setter
    def number_of_messages(self, number_of_messages):
        """Sets the number_of_messages of this InlineResponse2008ArchiveFiles.

        The number of `TXT` or `JSON` file messages. This field returns only when the `file_extension` is `JSON` or `TXT`  # noqa: E501

        :param number_of_messages: The number_of_messages of this InlineResponse2008ArchiveFiles.  # noqa: E501
        :type: int
        """

        self._number_of_messages = number_of_messages

    @property
    def storage_location(self):
        """Gets the storage_location of this InlineResponse2008ArchiveFiles.  # noqa: E501

        The region where the file is stored. This field returns only `Enable Distributed Compliance Archiving` op feature is enabled.  # noqa: E501

        :return: The storage_location of this InlineResponse2008ArchiveFiles.  # noqa: E501
        :rtype: str
        """
        return self._storage_location

    @storage_location.setter
    def storage_location(self, storage_location):
        """Sets the storage_location of this InlineResponse2008ArchiveFiles.

        The region where the file is stored. This field returns only `Enable Distributed Compliance Archiving` op feature is enabled.  # noqa: E501

        :param storage_location: The storage_location of this InlineResponse2008ArchiveFiles.  # noqa: E501
        :type: str
        """
        allowed_values = ["US", "AU", "BR", "CA", "EU", "IN", "JP", "SG", "CH"]  # noqa: E501
        if storage_location not in allowed_values:
            raise ValueError(
                "Invalid value for `storage_location` ({0}), must be one of {1}"  # noqa: E501
                .format(storage_location, allowed_values)
            )

        self._storage_location = storage_location

    @property
    def auto_delete(self):
        """Gets the auto_delete of this InlineResponse2008ArchiveFiles.  # noqa: E501

        Whether to auto delete the archived file.   **Prerequisites:**   * The \"Tag Archiving Files for Deletion\" feature must be enabled in OP. Contact [Zoom Support](https://support.zoom.us/hc/en-us/articles/201362003) to open.   # noqa: E501

        :return: The auto_delete of this InlineResponse2008ArchiveFiles.  # noqa: E501
        :rtype: bool
        """
        return self._auto_delete

    @auto_delete.setter
    def auto_delete(self, auto_delete):
        """Sets the auto_delete of this InlineResponse2008ArchiveFiles.

        Whether to auto delete the archived file.   **Prerequisites:**   * The \"Tag Archiving Files for Deletion\" feature must be enabled in OP. Contact [Zoom Support](https://support.zoom.us/hc/en-us/articles/201362003) to open.   # noqa: E501

        :param auto_delete: The auto_delete of this InlineResponse2008ArchiveFiles.  # noqa: E501
        :type: bool
        """

        self._auto_delete = auto_delete

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value
        if issubclass(InlineResponse2008ArchiveFiles, dict):
            for key, value in self.items():
                result[key] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, InlineResponse2008ArchiveFiles):
            return False

        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        return not self == other
